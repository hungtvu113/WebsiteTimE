name: üìä Code Quality & Performance

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # Ch·∫°y h√†ng ng√†y l√∫c 2:00 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:

env:
  NODE_VERSION: '18'
  PNPM_VERSION: '8.15.0'

jobs:
  # üìä SonarCloud Analysis
  sonarcloud:
    name: üìä SonarCloud Analysis
    runs-on: ubuntu-latest
    if: github.event_name != 'schedule' || github.ref == 'refs/heads/main'
    services:
      mongodb:
        image: mongo:6.0
        env:
          MONGO_INITDB_ROOT_USERNAME: admin
          MONGO_INITDB_ROOT_PASSWORD: password123
          MONGO_INITDB_DATABASE: qltime_test
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --eval 'db.adminCommand(\"ping\")'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for better analysis

      - name: üì¶ Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: üì• Install dependencies
        run: pnpm install --frozen-lockfile

      - name: üß™ Run tests with coverage
        run: |
          pnpm --filter backend test:cov
        env:
          MONGODB_URI: mongodb://admin:password123@localhost:27017/qltime_test?authSource=admin
          JWT_SECRET: test_jwt_secret
          NODE_ENV: test

      - name: üìä SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v5.0.0
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: https://sonarcloud.io

      - name: üìä SonarCloud Quality Gate
        uses: SonarSource/sonarqube-quality-gate-action@master
        continue-on-error: true
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: ‚ö†Ô∏è SonarCloud Status
        run: |
          if [ -z "${{ secrets.SONAR_TOKEN }}" ]; then
            echo "‚ö†Ô∏è SonarCloud analysis skipped - SONAR_TOKEN not configured"
            echo "To enable SonarCloud:"
            echo "1. Go to https://sonarcloud.io"
            echo "2. Import this repository"
            echo "3. Add SONAR_TOKEN to GitHub secrets"
          else
            echo "‚úÖ SonarCloud analysis completed (check steps above for results)"
          fi

  # ‚ö° Performance Testing
  performance:
    name: ‚ö° Performance Testing
    runs-on: ubuntu-latest
    services:
      mongodb:
        image: mongo:6.0
        env:
          MONGO_INITDB_ROOT_USERNAME: admin
          MONGO_INITDB_ROOT_PASSWORD: password123
          MONGO_INITDB_DATABASE: qltime_test
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --eval 'db.adminCommand(\"ping\")'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: üì• Install dependencies
        run: pnpm install --frozen-lockfile

      - name: üöÄ Start backend for testing
        run: |
          pnpm backend:build
          pnpm backend:start &
          echo $! > backend.pid
          
          # Wait for backend to start
          for i in {1..30}; do
            if curl -f http://localhost:3001/health > /dev/null 2>&1; then
              echo "‚úÖ Backend is ready"
              break
            fi
            echo "‚è≥ Waiting for backend... ($i/30)"
            sleep 2
          done
        env:
          MONGODB_URI: mongodb://admin:password123@localhost:27017/qltime_test?authSource=admin
          JWT_SECRET: test_jwt_secret
          NODE_ENV: production
          PORT: 3001

      - name: üì¶ Install Artillery and dependencies
        run: |
          npm install -g artillery@latest
          # Install bc for calculations
          sudo apt-get update && sudo apt-get install -y bc jq

      - name: ‚ö° Run API performance tests
        run: |
          echo "‚ö° Running API performance tests..."

          # Create performance test config if not exists
          if [ ! -f "performance-test.yml" ]; then
            cat > performance-test.yml << EOF
          config:
            target: 'http://localhost:3001'
            phases:
              - duration: 30
                arrivalRate: 5
                name: "Warm up"
              - duration: 60
                arrivalRate: 10
                name: "Load test"
              - duration: 30
                arrivalRate: 15
                name: "Stress test"

          scenarios:
            - name: "Health check"
              weight: 50
              flow:
                - get:
                    url: "/health"

            - name: "API endpoints"
              weight: 50
              flow:
                - get:
                    url: "/api"
                    expect:
                      - statusCode: 200
          EOF
          fi

          # Run performance tests v√† t·∫°o files ngay c·∫£ khi fail
          set +e
          artillery run performance-test.yml --output performance-results.json || echo "Performance test completed with warnings"
          set -e

          # T·∫°o file results n·∫øu kh√¥ng t·ªìn t·∫°i
          if [ ! -f "performance-results.json" ]; then
            echo '{"aggregate":{"counters":{"http.requests":0},"latency":{"mean":0,"p95":0,"p99":0}}}' > performance-results.json
          fi

          # Generate HTML report
          artillery report performance-results.json --output performance-report.html || echo "Report generation completed"

      - name: üìä Analyze performance results
        run: |
          echo "üìä Analyzing performance results..."

          # Extract key metrics
          if [ -f "performance-results.json" ]; then
            echo "üìà Performance Summary:"
            echo "- Total requests: $(jq '.aggregate.counters["http.requests"] // 0' performance-results.json)"
            echo "- Success rate: $(jq '.aggregate.counters["http.responses"] // 0' performance-results.json)"
            echo "- Average response time: $(jq '.aggregate.latency.mean // 0' performance-results.json)ms"
            echo "- 95th percentile: $(jq '.aggregate.latency.p95 // 0' performance-results.json)ms"
            echo "- 99th percentile: $(jq '.aggregate.latency.p99 // 0' performance-results.json)ms"

            # Check if performance is acceptable (only if we have valid data)
            AVG_RESPONSE=$(jq '.aggregate.latency.mean // 0' performance-results.json)
            P95_RESPONSE=$(jq '.aggregate.latency.p95 // 0' performance-results.json)

            # Only check if we have meaningful data
            if [ "$AVG_RESPONSE" != "0" ] && [ "$AVG_RESPONSE" != "null" ]; then
              if (( $(echo "$AVG_RESPONSE > 1000" | bc -l 2>/dev/null || echo 0) )); then
                echo "‚ö†Ô∏è Average response time is high: ${AVG_RESPONSE}ms"
              else
                echo "‚úÖ Average response time is acceptable: ${AVG_RESPONSE}ms"
              fi
            fi

            if [ "$P95_RESPONSE" != "0" ] && [ "$P95_RESPONSE" != "null" ]; then
              if (( $(echo "$P95_RESPONSE > 2000" | bc -l 2>/dev/null || echo 0) )); then
                echo "‚ö†Ô∏è 95th percentile response time is high: ${P95_RESPONSE}ms"
              else
                echo "‚úÖ 95th percentile response time is acceptable: ${P95_RESPONSE}ms"
              fi
            fi
          else
            echo "‚ö†Ô∏è Performance results file not found, creating empty report"
            echo '{"message": "Performance test was skipped or failed"}' > performance-results.json
          fi

      - name: üõë Stop backend
        if: always()
        run: |
          if [ -f backend.pid ]; then
            kill $(cat backend.pid) || true
            rm backend.pid
          fi

      - name: üì¶ Upload performance results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: performance-results
          path: |
            performance-results.json
            performance-report.html
            performance-test.yml
          retention-days: 30
          if-no-files-found: warn

  # üåê Frontend Lighthouse Audit
  lighthouse:
    name: üåê Lighthouse Audit
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: üì• Install dependencies
        run: pnpm install --frozen-lockfile

      - name: üèóÔ∏è Build frontend
        run: pnpm frontend:build
        env:
          NEXT_PUBLIC_API_URL: http://localhost:3001

      - name: üöÄ Start frontend
        run: |
          pnpm frontend:start &
          echo $! > frontend.pid
          
          # Wait for frontend to start
          for i in {1..30}; do
            if curl -f http://localhost:3000 > /dev/null 2>&1; then
              echo "‚úÖ Frontend is ready"
              break
            fi
            echo "‚è≥ Waiting for frontend... ($i/30)"
            sleep 2
          done

      - name: üåê Run Lighthouse CI
        run: |
          npm install -g @lhci/cli@latest
          
          # Create Lighthouse CI config if not exists
          if [ ! -f ".lighthouserc.json" ]; then
            cat > .lighthouserc.json << EOF
          {
            "ci": {
              "collect": {
                "url": ["http://localhost:3000"],
                "numberOfRuns": 3
              },
              "assert": {
                "assertions": {
                  "categories:performance": ["warn", {"minScore": 0.8}],
                  "categories:accessibility": ["error", {"minScore": 0.9}],
                  "categories:best-practices": ["warn", {"minScore": 0.8}],
                  "categories:seo": ["warn", {"minScore": 0.8}]
                }
              },
              "upload": {
                "target": "temporary-public-storage"
              }
            }
          }
          EOF
          fi
          
          lhci autorun

      - name: üõë Stop frontend
        if: always()
        run: |
          if [ -f frontend.pid ]; then
            kill $(cat frontend.pid) || true
            rm frontend.pid
          fi

  # üîí Security Analysis
  security:
    name: üîí Security Analysis
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîç Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript

      - name: üîç Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

      - name: üîí Run Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/javascript
            p/typescript
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}

  # üìö Documentation Check
  docs:
    name: üìö Documentation Check
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üìö Check README files
        run: |
          echo "üìö Checking documentation..."
          
          # Check if main README exists and is not empty
          if [ ! -f "README.md" ] || [ ! -s "README.md" ]; then
            echo "‚ùå Main README.md is missing or empty"
            exit 1
          fi
          
          # Check for other important docs
          DOCS_TO_CHECK=("frontend/README.md" "backend/README.md")
          
          for doc in "${DOCS_TO_CHECK[@]}"; do
            if [ ! -f "$doc" ]; then
              echo "‚ö†Ô∏è Missing documentation: $doc"
            else
              echo "‚úÖ Found: $doc"
            fi
          done

      - name: üìù Check for TODO comments
        run: |
          echo "üìù Checking for TODO comments..."
          
          TODO_COUNT=$(grep -r "TODO\|FIXME\|HACK" --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" . | wc -l)
          
          echo "üìù Found $TODO_COUNT TODO/FIXME/HACK comments"
          
          if [ "$TODO_COUNT" -gt 50 ]; then
            echo "‚ö†Ô∏è High number of TODO comments found. Consider addressing some of them."
          fi

      - name: üìä Generate documentation report
        run: |
          echo "üìä Generating documentation report..."
          
          cat > docs-report.md << EOF
          # üìö Documentation Report
          
          Generated on: $(date)
          
          ## üìã Documentation Status
          - Main README: $([ -f "README.md" ] && echo "‚úÖ Present" || echo "‚ùå Missing")
          - Frontend README: $([ -f "frontend/README.md" ] && echo "‚úÖ Present" || echo "‚ùå Missing")
          - Backend README: $([ -f "backend/README.md" ] && echo "‚úÖ Present" || echo "‚ùå Missing")
          - Docker README: $([ -f "README-DOCKER.md" ] && echo "‚úÖ Present" || echo "‚ùå Missing")
          
          ## üìù Code Comments
          - TODO comments: $(grep -r "TODO" --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" . | wc -l)
          - FIXME comments: $(grep -r "FIXME" --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" . | wc -l)
          - HACK comments: $(grep -r "HACK" --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" . | wc -l)
          EOF

      - name: üì¶ Upload documentation report
        uses: actions/upload-artifact@v4
        with:
          name: documentation-report
          path: docs-report.md
          retention-days: 30
